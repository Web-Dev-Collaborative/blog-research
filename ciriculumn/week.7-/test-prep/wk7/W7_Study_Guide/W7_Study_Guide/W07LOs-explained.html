<h1 id="github-big-o-and-intro-to-data-structures-and-algorithms-week-7---learning-objectives">GitHub, Big-O, and Intro to Data Structures and Algorithms (Week 7) - Learning Objectives</h1>
<h2 id="assessment-structure">Assessment Structure</h2>
<ul>
<li>2 hours</li>
<li>Mixture of multiple choice (10-15) and VSCode (3-5) problems, each with multiple specs.
<ul>
<li>Coding problems will have specs to run (<code>npm test</code>) and check your work against</li>
</ul></li>
<li>Standard assessment procedures
<ul>
<li>You will be in an individual breakout room</li>
<li>Use a single monitor and share your screen</li>
<li>Only have open those resources needed to complete the assessment:
<ul>
<li>Zoom</li>
<li>VSCode</li>
<li>Browser with AAO and Progress Tracker (to ask questions)</li>
<li>Approved Resources for this assessment:</li>
<li>MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript</li>
</ul></li>
</ul></li>
</ul>
<h2 id="binary-search-w7d1---learning-objectives">Binary Search (W7D1) - Learning Objectives</h2>
<ol type="1">
<li>Explain the complexity of and write a function that performs a binary search on a sorted array of numbers.</li>
</ol>
<ul>
<li>Time Complexity: O(log n)
<ul>
<li>With each recursive call, we split our input in half. This means we have to make at most log n checks to know if the element is in our array.</li>
</ul></li>
<li>Space Complexity: Our implementation O(n), Possible implementation O(1)
<ul>
<li>We have to make a subarray for each recursive call. In the worst case (we donâ€™t find the element), the total length of these arrays is approximately equal to the length of the original (n).</li>
<li>If we kept references to the beginning and end index of the portion of the array that we are searching, we could eliminate the need for creating new subarrays. We could also use a while loop to perform this functionality until we either found our target or our beginning and end indices crossed. This would eliminate the space required for recursive calls (adding stack frames). Ultimately we would be using the same number of variables independent of input size, resulting in O(1).</li>
</ul></li>
<li>Code example for binarySearch and binarySearchIndex:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// Returns simply true/false for presence</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">function</span> <span class="at">binarySearch</span>(array<span class="op">,</span> target) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-4" title="4">      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-8" title="8">  <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="cf">if</span> (target <span class="op">&lt;</span> array[midIdx]) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-12" title="12">      <span class="cf">return</span> <span class="at">binarySearch</span>(leftHalf<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-13" title="13">  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (target <span class="op">&gt;</span> array[midIdx]) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-14" title="14">      <span class="cf">return</span> <span class="at">binarySearch</span>(rightHalf<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-15" title="15">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-16" title="16">      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-19" title="19"></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">// Returns the index or -1 if not found</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="kw">function</span> <span class="at">binarySearchIndex</span>(array<span class="op">,</span> target) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-22" title="22">  <span class="cf">if</span> (<span class="op">!</span><span class="va">array</span>.<span class="at">length</span>) <span class="cf">return</span> <span class="dv">-1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24">  <span class="kw">const</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-25" title="25">  <span class="kw">const</span> midEl <span class="op">=</span> array[midIdx]<span class="op">;</span></a>
<a class="sourceLine" id="cb1-26" title="26"></a>
<a class="sourceLine" id="cb1-27" title="27">  <span class="cf">if</span> (target <span class="op">&lt;</span> midEl) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-28" title="28">    <span class="cf">return</span> <span class="at">binarySearchIndex</span>(<span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-29" title="29">  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (target <span class="op">&gt;</span> midEl) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-30" title="30">    <span class="co">// Since our recursive call will have new indices for the subarray, we have</span></a>
<a class="sourceLine" id="cb1-31" title="31">    <span class="co">// to adjust the return value to align it with the indices of our original</span></a>
<a class="sourceLine" id="cb1-32" title="32">    <span class="co">// array.</span></a>
<a class="sourceLine" id="cb1-33" title="33">    <span class="co">// If the recursive call returns -1, it was not found and we can immediately</span></a>
<a class="sourceLine" id="cb1-34" title="34">    <span class="co">// return -1</span></a>
<a class="sourceLine" id="cb1-35" title="35">    <span class="co">// If it was found in the subarray, we have to add on the number of elements</span></a>
<a class="sourceLine" id="cb1-36" title="36">    <span class="co">// that were removed from the beginning of our larger original array.</span></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="co">// For example, if we try to find 15 in an array of [5, 10, 15]:</span></a>
<a class="sourceLine" id="cb1-38" title="38">    <span class="co">//   - Our first call to binarySearchIndex will check our middle element of 10</span></a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="co">//   - Since our target is greater, we will recursively call our search on</span></a>
<a class="sourceLine" id="cb1-40" title="40">    <span class="co">//   elements to the right, being the subarray [15]</span></a>
<a class="sourceLine" id="cb1-41" title="41">    <span class="co">//   - On our recursive call we found our target! It&#39;s index in this call is 0.</span></a>
<a class="sourceLine" id="cb1-42" title="42">    <span class="co">//   - When we return 0 to where binarySearchIndex was called, we need to</span></a>
<a class="sourceLine" id="cb1-43" title="43">    <span class="co">//   adjust it to line up with this larger array (the 0th element of this</span></a>
<a class="sourceLine" id="cb1-44" title="44">    <span class="co">//   larger array is 5, but our target was at the 0th index of the subarray)</span></a>
<a class="sourceLine" id="cb1-45" title="45">    <span class="co">//   - Since we sliced off 2 elements from the beginning before making our</span></a>
<a class="sourceLine" id="cb1-46" title="46">    <span class="co">//   recursive call, we add 2 to the return value to adjust it back to line up</span></a>
<a class="sourceLine" id="cb1-47" title="47">    <span class="co">//   with our original array.</span></a>
<a class="sourceLine" id="cb1-48" title="48"></a>
<a class="sourceLine" id="cb1-49" title="49">    <span class="kw">const</span> idxShift <span class="op">=</span> <span class="at">binarySearchIndex</span>(<span class="va">array</span>.<span class="at">slice</span>(midIdx <span class="op">+</span> <span class="dv">1</span>)<span class="op">,</span> target)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-50" title="50">    <span class="cf">return</span> idxShift <span class="op">===</span> <span class="dv">-1</span> <span class="op">?</span> <span class="dv">-1</span> : idxShift <span class="op">+</span> midIdx <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-51" title="51">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-52" title="52">    <span class="cf">return</span> midIdx<span class="op">;</span></a>
<a class="sourceLine" id="cb1-53" title="53">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-54" title="54"><span class="op">}</span></a></code></pre></div>
<h2 id="sorting-algorithms-w7d2---learning-objectives">Sorting Algorithms (W7D2) - Learning Objectives</h2>
<ol type="1">
<li>Explain the complexity of and write a function that performs bubble sort on an array of numbers.</li>
</ol>
<ul>
<li>Time Complexity: O(n^2)
<ul>
<li>In our worst case, our input is in the opposite order. We have to perform n swaps and loop through our input n times because a swap is made each time.</li>
</ul></li>
<li>Space Complexity: O(1)
<ul>
<li>We are creating the same number of variables with an exact size, independent of our input. No new arrays are created.</li>
</ul></li>
<li>Code example for bubbleSort:</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">function</span> <span class="at">bubbleSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">let</span> swapped <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="cf">while</span>(swapped) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-5" title="5">    swapped <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">array</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-8" title="8">      <span class="cf">if</span> (array[i] <span class="op">&gt;</span> array[i<span class="op">+</span><span class="dv">1</span>]) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-9" title="9">        <span class="kw">let</span> temp <span class="op">=</span> array[i]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-10" title="10">        array[i] <span class="op">=</span> array[i <span class="op">+</span> <span class="dv">1</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb2-11" title="11">        array[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> temp<span class="op">;</span></a>
<a class="sourceLine" id="cb2-12" title="12">        <span class="co">// The above three lines could also be in a helper swap function</span></a>
<a class="sourceLine" id="cb2-13" title="13">        <span class="co">// swap(array, i, i+1);</span></a>
<a class="sourceLine" id="cb2-14" title="14">        swapped <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-15" title="15">      <span class="op">}</span></a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb2-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-18" title="18"></a>
<a class="sourceLine" id="cb2-19" title="19">  <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb2-20" title="20"><span class="op">}</span></a></code></pre></div>
<ol start="2" type="1">
<li>Explain the complexity of and write a function that performs selection sort on an array of numbers.</li>
</ol>
<ul>
<li>Time Complexity: O(n^2)
<ul>
<li>Our nested loop structure is dependent on the size of our input.</li>
<li>The outer loop always occurs n times.</li>
<li>For each of those iterations, we have another loop that runs (n - i) times. This just means that the inner loop runs one less time each iteration, but this averages out to (n/2).</li>
<li>Our nested structure is then T(n * n/2) = O(n^2)</li>
</ul></li>
<li>Space Complexity: O(1)
<ul>
<li>We are creating the same number of variables with an exact size, independent of our input. No new arrays are created.</li>
</ul></li>
<li>Code example for selectSort:</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span> <span class="at">selectionSort</span>(arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">let</span> minIndex <span class="op">=</span> i<span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-6" title="6">      <span class="cf">if</span> (arr[minIndex] <span class="op">&gt;</span> arr[j]) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-7" title="7">        minIndex <span class="op">=</span> j<span class="op">;</span></a>
<a class="sourceLine" id="cb3-8" title="8">      <span class="op">}</span></a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="kw">let</span> temp <span class="op">=</span> arr[i]<span class="op">;</span></a>
<a class="sourceLine" id="cb3-12" title="12">    arr[i] <span class="op">=</span> arr[minIndex]<span class="op">;</span></a>
<a class="sourceLine" id="cb3-13" title="13">    arr[minIndex] <span class="op">=</span> temp<span class="op">;</span></a>
<a class="sourceLine" id="cb3-14" title="14">    <span class="co">// The above three lines could also be in a helper swap function</span></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="co">// swap(arr, i, minIndex);</span></a>
<a class="sourceLine" id="cb3-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-17" title="17">  <span class="cf">return</span> arr<span class="op">;</span></a>
<a class="sourceLine" id="cb3-18" title="18"><span class="op">}</span></a></code></pre></div>
<ol start="3" type="1">
<li>Explain the complexity of and write a function that performs insertion sort on an array of numbers.</li>
</ol>
<ul>
<li>Time Complexity: O(n^2)
<ul>
<li>Our nested loop structure is dependent on the size of our input.</li>
<li>The outer loop always occurs n times.</li>
<li>For each of those iterations, we have another loop that runs a maximum of (i - 1) times. This just means that the inner loop runs one more time each iteration, but this averages out to (n/2).</li>
<li>Our nested structure is then T(n * n/2) = O(n^2)</li>
</ul></li>
<li>Space Complexity: O(1)
<ul>
<li>We are creating the same number of variables with an exact size, independent of our input. No new arrays are created.</li>
</ul></li>
<li>Code example for insertionSort:</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">function</span> <span class="at">insertionSort</span>(arr) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">arr</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">let</span> currElement <span class="op">=</span> arr[i]<span class="op">;</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="cf">for</span> (<span class="kw">var</span> j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> currElement <span class="op">&lt;</span> arr[j]<span class="op">;</span> j<span class="op">--</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-5" title="5">      arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> arr[j]<span class="op">;</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb4-7" title="7">    arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> currElement<span class="op">;</span></a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb4-9" title="9">  <span class="cf">return</span> arr<span class="op">;</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="op">}</span></a></code></pre></div>
<ol start="4" type="1">
<li>Explain the complexity of and write a function that performs merge sort on an array of numbers.</li>
</ol>
<ul>
<li>Time Complexity: O(n log n)
<ul>
<li>Our mergeSort function divides our input in half at each step, recursively calling itself with smaller and smaller input. This results in log n stack frames.</li>
<li>On each stack frame, our worst case scenario is having to make n comparisons in our merge function in order to determine which element should come next in our sorted array.</li>
<li>Since we have log n stack frames and n operations on each frame, we end up with an O(n log n) time complexity</li>
</ul></li>
<li>Space Complexity: O(n)
<ul>
<li>We are ultimately creating n subarrays, making our space complexity linear to our input size.</li>
</ul></li>
<li>Code example for mergeSort:</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// The merge function is what is combining our sorted sub-arrays</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">function</span> <span class="at">merge</span>(array1<span class="op">,</span> array2) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="kw">let</span> merged <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="co">// keep running while either array still contains elements</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="cf">while</span> (<span class="va">array1</span>.<span class="at">length</span> <span class="op">||</span> <span class="va">array2</span>.<span class="at">length</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="co">// if array1 is nonempty, take its the first element as ele1</span></a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="co">// otherwise array1 is empty, so take Infinity as ele1</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">let</span> ele1 <span class="op">=</span> <span class="va">array1</span>.<span class="at">length</span> <span class="op">?</span> array1[<span class="dv">0</span>] : <span class="kw">Infinity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-10" title="10"></a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="co">// do the same for array2, ele2</span></a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="kw">let</span> ele2 <span class="op">=</span> <span class="va">array2</span>.<span class="at">length</span> <span class="op">?</span> array2[<span class="dv">0</span>] : <span class="kw">Infinity</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-13" title="13"></a>
<a class="sourceLine" id="cb5-14" title="14">    <span class="kw">let</span> next<span class="op">;</span></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="co">// remove the smaller of the eles from it&#39;s array</span></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="cf">if</span> (ele1 <span class="op">&lt;</span> ele2) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-17" title="17">      next <span class="op">=</span> <span class="va">array1</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-19" title="19">      next <span class="op">=</span> <span class="va">array2</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb5-20" title="20">    <span class="op">}</span></a>
<a class="sourceLine" id="cb5-21" title="21"></a>
<a class="sourceLine" id="cb5-22" title="22">    <span class="co">// and add that ele to the new array</span></a>
<a class="sourceLine" id="cb5-23" title="23">    <span class="va">merged</span>.<span class="at">push</span>(next)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb5-25" title="25"></a>
<a class="sourceLine" id="cb5-26" title="26">  <span class="cf">return</span> merged<span class="op">;</span></a>
<a class="sourceLine" id="cb5-27" title="27"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-28" title="28"></a>
<a class="sourceLine" id="cb5-29" title="29"><span class="co">// The mergeSort function breaks apart our input into smaller sub-arrays until</span></a>
<a class="sourceLine" id="cb5-30" title="30"><span class="co">//we have an input of length &lt;= 1, which is inherently sorted.</span></a>
<a class="sourceLine" id="cb5-31" title="31"><span class="co">// Once we have a left and right subarray that&#39;s sorted, we can merge them</span></a>
<a class="sourceLine" id="cb5-32" title="32"><span class="co">//together to get our sorted result of this sub-problem, passing the sorted</span></a>
<a class="sourceLine" id="cb5-33" title="33"><span class="co">//version back up the call stack.</span></a>
<a class="sourceLine" id="cb5-34" title="34"><span class="kw">function</span> <span class="at">mergeSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-35" title="35">  <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-36" title="36">    <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb5-37" title="37">  <span class="op">}</span></a>
<a class="sourceLine" id="cb5-38" title="38"></a>
<a class="sourceLine" id="cb5-39" title="39">  <span class="kw">let</span> midIdx <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">array</span>.<span class="at">length</span> / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-40" title="40">  <span class="kw">let</span> leftHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-41" title="41">  <span class="kw">let</span> rightHalf <span class="op">=</span> <span class="va">array</span>.<span class="at">slice</span>(midIdx)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-42" title="42"></a>
<a class="sourceLine" id="cb5-43" title="43">  <span class="kw">let</span> sortedLeft <span class="op">=</span> <span class="at">mergeSort</span>(leftHalf)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-44" title="44">  <span class="kw">let</span> sortedRight <span class="op">=</span> <span class="at">mergeSort</span>(rightHalf)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-45" title="45"></a>
<a class="sourceLine" id="cb5-46" title="46">  <span class="cf">return</span> <span class="at">merge</span>(sortedLeft<span class="op">,</span> sortedRight)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-47" title="47"><span class="op">}</span></a></code></pre></div>
<ol start="5" type="1">
<li>Explain the complexity of and write a function that performs quick sort on an array of numbers.</li>
</ol>
<ul>
<li>Time Complexity: Average O(n log n), Worst O(n^2)
<ul>
<li>In our worst case, the pivot that we select results in every element going into either the left or right array. If this happens we end up making n recursive calls to quickSort, with n comparisons at each call.</li>
<li>In our average case, we pick something that more evenly splits the arrays, resulting in approximately log n recursive calls and an overall complexity of O(n log n).</li>
<li>Quick sort is unique in that the worst case is so exceedingly rare that it is often considered an O(n log n) complexity, even though this is not technically accurate.</li>
</ul></li>
<li>Space Complexity: Our implementation O(n), Possible implementation O(log n)
<ul>
<li>The partition arrays that we create are directly proportional to the size of the input, resulting in O(n) space complexity.</li>
<li>With some tweaking, we could implement an in-place quick sort, which would eliminate the creation of new arrays. In this case, the log n stack frames from the recursion are the only proportional amount of space that is used, resulting in O(log n) space complexity.</li>
</ul></li>
<li>Code example for quickSort:</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">function</span> <span class="at">quickSort</span>(array) <span class="op">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="cf">if</span> (<span class="va">array</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb6-3" title="3">      <span class="cf">return</span> array<span class="op">;</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="kw">let</span> pivot <span class="op">=</span> <span class="va">array</span>.<span class="at">shift</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="co">// This implementation uses filter, which returns a new array with any element</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="co">//that passes the criteria (ie the callback returns true).</span></a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="co">// We also could have iterated over the array (array.forEach(el =&gt; ...)) and</span></a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="co">//pushed each value into the appropriate left/right subarray as we encountered</span></a>
<a class="sourceLine" id="cb6-11" title="11">  <span class="co">// it.</span></a>
<a class="sourceLine" id="cb6-12" title="12">  <span class="kw">let</span> left <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&lt;</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="kw">let</span> right <span class="op">=</span> <span class="va">array</span>.<span class="at">filter</span>(el <span class="kw">=&gt;</span> el <span class="op">&gt;=</span> pivot)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15">  <span class="kw">let</span> leftSorted <span class="op">=</span> <span class="at">quickSort</span>(left)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="kw">let</span> rightSorted <span class="op">=</span> <span class="at">quickSort</span>(right)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-17" title="17"></a>
<a class="sourceLine" id="cb6-18" title="18">  <span class="cf">return</span> [ ...<span class="at">leftSorted</span><span class="op">,</span> pivot<span class="op">,</span> ...<span class="at">rightSorted</span> ]<span class="op">;</span></a>
<a class="sourceLine" id="cb6-19" title="19">  <span class="co">// We also could have concatenated the arrays instead of spreading their contents</span></a>
<a class="sourceLine" id="cb6-20" title="20">  <span class="co">// return leftSorted.concat([pivot]).concat(rightSorted);</span></a>
<a class="sourceLine" id="cb6-21" title="21"><span class="op">}</span></a></code></pre></div>
<h2 id="big-o-memoization-and-tabulation-w7d3---learning-objectives">Big-O, Memoization, and Tabulation (W7D3) - Learning Objectives</h2>
<h3 id="big-o">Big-O</h3>
<ol type="1">
<li>Order the common complexity classes according to their growth rate</li>
</ol>
<ul>
<li>The following are in order from smallest growth (most efficient) to largest:
<ul>
<li>constant O(1)</li>
<li>logarithmic O(log n)</li>
<li>linear O(n)</li>
<li>loglinear, linearithmic, quasilinear O(n log n)</li>
<li>polynomial O(n^c) -&gt; O(n^2), O(n^3)</li>
<li>exponential O(c^n) -&gt; O(2^n), O(3^n)</li>
<li>factorial O(n!)</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>Identify the complexity classes of common sort methods</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Sort Name</th>
<th style="text-align: left;">Time Complexity</th>
<th style="text-align: left;">Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bubble</td>
<td style="text-align: left;">O(n^2)</td>
<td style="text-align: left;">O(1)</td>
</tr>
<tr class="even">
<td style="text-align: left;">selection</td>
<td style="text-align: left;">O(n^2)</td>
<td style="text-align: left;">O(1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">insertion</td>
<td style="text-align: left;">O(n^2)</td>
<td style="text-align: left;">O(1)</td>
</tr>
<tr class="even">
<td style="text-align: left;">merge</td>
<td style="text-align: left;">O(n log n)</td>
<td style="text-align: left;">O(n)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">quick</td>
<td style="text-align: left;">*O(n log n)/O(n^2)</td>
<td style="text-align: left;">*O(n)/O(log n)</td>
</tr>
</tbody>
</table>
<ul>
<li>*quick sortâ€™s complexities are a little more complicated
<ul>
<li>We are generally only concerned with the worst-scenario when we talk Big-O.</li>
<li>With quick sort, the worst case is exceedingly rare (only occurs when our pivot for each round happens to be the next element, resulting in us having to choose n pivot points)</li>
<li>Because it is so rare that this occurs, most people will use consider quick sort to be closer to O(n log n) time complexity.</li>
<li>We also have two space complexities listed. The version that we used in class creates a new array, resulting in O(n) space. With some tweaking, we can sort in place, modifying the original array and cutting our space complexity to O(log n), which is just a result of the stack frames that we have to create. Itâ€™s good to know this method exists, but you will not need to create or identify this version.</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li>Identify complexity classes of code</li>
</ol>
<ul>
<li>Important takeaway here is being able to connect code patterns with complexities
<ul>
<li>Doing an exact number of calculations (independent of input) -&gt; constant O(n)</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">function</span> <span class="at">constant_1</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="cf">return</span> n <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Looping an exact number of times (independent of input) -&gt; constant O(n)</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">function</span> <span class="at">constant_2</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(i)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Recursive calls that divide the input -&gt; logarithmic O(log n)</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">function</span> <span class="at">logarithmic</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="cf">if</span> (n <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="at">logarithmic</span>(n / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Loops that depend on the size of the input -&gt; linear O(n)</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">function</span> <span class="at">linear_1</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(i)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Recursive calls that depend on the size of the input (decrementing instead of dividing) -&gt; linear O(n)</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">function</span> <span class="at">linear_2</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="at">linear_2</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Looping through input on each stack frame, while recursively dividing our data (commonly seen in sorts like merge and quick sort) -&gt; loglinear O(n log n)</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">function</span> <span class="at">loglinear</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="cf">if</span> (n <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span> <span class="co">// n calculations in each stack frame</span></a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb12-6" title="6">  <span class="at">loglinear</span>(n / <span class="dv">2</span>)<span class="op">;</span> <span class="co">// log n number of stack frames</span></a>
<a class="sourceLine" id="cb12-7" title="7">  <span class="at">loglinear</span>(n / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Nesting loops that depend on the size of the input -&gt; polynomial O(n^c)</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// O(n^2)</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">function</span> <span class="at">quadratic</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-5" title="5">      <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`</span><span class="sc">${</span>i<span class="sc">}</span><span class="vs">, </span><span class="sc">${</span>j<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb13-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb13-9" title="9"></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="co">// O(n^3)</span></a>
<a class="sourceLine" id="cb13-11" title="11"><span class="kw">function</span> <span class="at">cubic</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-12" title="12">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-13" title="13">    <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-14" title="14">      <span class="cf">for</span> (<span class="kw">let</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;=</span> n<span class="op">;</span> k<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-15" title="15">        <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`</span><span class="sc">${</span>i<span class="sc">}</span><span class="vs">, </span><span class="sc">${</span>j<span class="sc">}</span><span class="vs">, </span><span class="sc">${</span>k<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-16" title="16">      <span class="op">}</span></a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb13-18" title="18">  <span class="op">}</span></a>
<a class="sourceLine" id="cb13-19" title="19"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Branching out on each recursive call, with the number of calls dependent on the size of the input -&gt; exponential O(c^n)</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// O(2^n)</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="kw">function</span> <span class="at">exponential_2n</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-5" title="5">  <span class="at">exponential_2n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="at">exponential_2n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb14-8" title="8"></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="co">// O(3^n)</span></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="kw">function</span> <span class="at">exponential_3n</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-11" title="11">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-12" title="12">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-13" title="13">  <span class="at">exponential_3n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-14" title="14">  <span class="at">exponential_3n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-15" title="15">  <span class="at">exponential_3n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-16" title="16"><span class="op">}</span></a></code></pre></div>
<ul>
<li>When both the number of recursive calls and the number of branches made in the calls are dependent on the size of the input -&gt; factorial O(n!)</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">function</span> <span class="at">factorial</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span> <span class="co">// Here we&#39;re making n branches on this frame</span></a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="at">factorial</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span> <span class="co">// Since we are decrementing, we&#39;re making n stack frames</span></a>
<a class="sourceLine" id="cb15-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="op">}</span></a></code></pre></div></li>
</ul>
<h3 id="memoization-and-tabulation">Memoization and Tabulation</h3>
<ol type="1">
<li>Apply memoization to recursive problems to make them less than polynomial time.</li>
</ol>
<ul>
<li>Main steps for memoizing a problem:
<ol type="1">
<li>Write out the brute force recursion</li>
<li>Add the memo object as an additional argument</li>
</ol>
<ul>
<li>Keys on this object represent input, values are the corresponding output</li>
</ul>
<ol start="3" type="1">
<li>Add a base condition that returns the stored value if the argument is already in the memo</li>
<li>Before returning a calculation, store the result in the memo for future use</li>
</ol></li>
<li>Example of a standard and memoized fibonacci:</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="co">// Standard Implementation</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="co">// Time Complexity: O(2^n)</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">//   - For each call to fib, we have to make two branches, with n levels to this</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="co">// tree</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="kw">function</span> <span class="at">fib</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-6" title="6">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span> <span class="op">||</span> n <span class="op">===</span> <span class="dv">2</span>) <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb16-7" title="7">  <span class="cf">return</span> <span class="at">fib</span>(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> <span class="at">fib</span>(n <span class="op">-</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb16-9" title="9"></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="co">// Using memoization</span></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="co">// Time Complexity: O(n)</span></a>
<a class="sourceLine" id="cb16-12" title="12"><span class="co">//   - We only ever have to calculate fib(x) one time, every other time that we</span></a>
<a class="sourceLine" id="cb16-13" title="13"><span class="co">// use it in a larger problem, the result is immediately accessible in our memo</span></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="co">//   - The memo removes the repeated trees of calculations from our original code</span></a>
<a class="sourceLine" id="cb16-15" title="15"><span class="kw">function</span> <span class="at">fib</span>(n<span class="op">,</span> memo <span class="op">=</span> <span class="op">{}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-16" title="16">  <span class="cf">if</span> (n <span class="kw">in</span> memo) <span class="cf">return</span> memo[n]<span class="op">;</span> <span class="co">// If we already calculated this value, return it</span></a>
<a class="sourceLine" id="cb16-17" title="17">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span> <span class="op">||</span> n <span class="op">===</span> <span class="dv">2</span>) <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb16-18" title="18"></a>
<a class="sourceLine" id="cb16-19" title="19">  <span class="co">// Store the result in the memo first before returning</span></a>
<a class="sourceLine" id="cb16-20" title="20">  <span class="co">// Make sure to pass the memo in to your calls to fib!</span></a>
<a class="sourceLine" id="cb16-21" title="21">  memo[n] <span class="op">=</span> <span class="at">fib</span>(n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo) <span class="op">+</span> <span class="at">fib</span>(n <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> memo)<span class="op">;</span> </a>
<a class="sourceLine" id="cb16-22" title="22">  <span class="cf">return</span> memo[n]<span class="op">;</span></a>
<a class="sourceLine" id="cb16-23" title="23"><span class="op">}</span></a></code></pre></div>
<ol start="2" type="1">
<li>Apply tabulation to iterative problems to make them less than polynomial time</li>
</ol>
<ul>
<li>Main considerations for using tabulation:
<ul>
<li>Figure out how big is your table
<ul>
<li>Typically going to be base on input size (number in fibonacci, length of string in wordBreak)</li>
</ul></li>
<li>What does my table represent?
<ul>
<li>You are generally building up your answer.</li>
<li>In fibonacci, we used the table to store the fib number at the corresponding index.</li>
<li>In stepper, we stored the boolean of whether it was possible to get to that location.</li>
</ul></li>
<li>What initial values do I need to seed?
<ul>
<li>Consider what your end result should be (boolean, number, etc.).</li>
<li>Your seed data is generally going to be the immediate answer that we know from our base condition.</li>
<li>In fibonacci, we knew the first two numbers of the series.</li>
<li>In stepper, we knew that it was possible to get to our starting location, so we seeded it as true, defaulting the rest to false so that we could later change its value if we could make that step.</li>
</ul></li>
<li>How do I iterate and fill out my table?
<ul>
<li>We typically need to iterate over or up to our input in some way in order to update and build up our table until we get our final result.</li>
<li>In fibonacci, we iterated up to our input number in order to calculate the fib number at each step.</li>
<li>In stepper, we iterated over each possible stepping location. If we could have made it to that point from our previous steps (ie that index was true in our table), we continued updating our table by marking the possible landing spots as true.</li>
</ul></li>
</ul></li>
<li>Example of a tabulated fibonacci:</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// Using tabulation</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="co">// Time Complexity: O(n)</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="co">//   - We are iterating through an array directly related to the size of the input</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="co">// and performing a constant number of calculations at each step (adding our two</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="co">// previous values together and storing the result in the array).</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="kw">function</span> <span class="at">fib</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-7" title="7">  <span class="co">// We create a table to track our values as we build them up</span></a>
<a class="sourceLine" id="cb17-8" title="8">  <span class="co">// We&#39;re making it n+1 here so that table[n] lines up with the nth fib number</span></a>
<a class="sourceLine" id="cb17-9" title="9">  <span class="co">// This is because arrays are zero-indexed.</span></a>
<a class="sourceLine" id="cb17-10" title="10">  <span class="co">// We could have used an array of length n, but we would have to remember that </span></a>
<a class="sourceLine" id="cb17-11" title="11">  <span class="co">// the nth fib number would then be stored at table[n-1]. Completely doable,</span></a>
<a class="sourceLine" id="cb17-12" title="12">  <span class="co">// but I think making them line up is more intuitive.</span></a>
<a class="sourceLine" id="cb17-13" title="13">  <span class="kw">let</span> table <span class="op">=</span> <span class="kw">new</span> <span class="at">Array</span>(n <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span> </a>
<a class="sourceLine" id="cb17-14" title="14">  <span class="co">// Seed our table with our starting values.</span></a>
<a class="sourceLine" id="cb17-15" title="15">  <span class="co">// Again, if we had a table of length n, we could have seeded table[0] = 1</span></a>
<a class="sourceLine" id="cb17-16" title="16">  <span class="co">// and table[1] = 1 and had the same final result with our indices shifted.</span></a>
<a class="sourceLine" id="cb17-17" title="17">  table[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb17-18" title="18">  table[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb17-19" title="19"></a>
<a class="sourceLine" id="cb17-20" title="20">  <span class="co">// Iterate through our input and fill out our table as we go.</span></a>
<a class="sourceLine" id="cb17-21" title="21">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">table</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-22" title="22">    table[i] <span class="op">=</span> table[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> table[i <span class="op">-</span> <span class="dv">2</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb17-23" title="23">  <span class="op">}</span></a>
<a class="sourceLine" id="cb17-24" title="24"></a>
<a class="sourceLine" id="cb17-25" title="25">  <span class="co">// At the end, the final entry in our table is the result we are looking for.</span></a>
<a class="sourceLine" id="cb17-26" title="26">  <span class="co">// The table holds all of the sub-answers that we used to get to this result.</span></a>
<a class="sourceLine" id="cb17-27" title="27">  <span class="cf">return</span> table[n]<span class="op">;</span></a>
<a class="sourceLine" id="cb17-28" title="28"><span class="op">}</span></a></code></pre></div>
<h2 id="lists-stacks-and-queues-w7d4---learning-objectives">Lists, Stacks, and Queues (W7D4) - Learning Objectives</h2>
<h3 id="lists-stacks-and-queues">Lists, Stacks, and Queues</h3>
<ol type="1">
<li>Explain and implement a Linked List.</li>
</ol>
<ul>
<li>A linked list are a collection of ordered data that track three main components:
<ul>
<li>head: beginning of the list</li>
<li>tail: end of the list</li>
<li>length: count of the number of elements in the list</li>
</ul></li>
<li>The main differences between lists and arrays are that a list does not have random access or indices to signify where in the list an element is.
<ul>
<li>The only references to elements that we have in a list are the head and the tail.</li>
<li>If we want an element in the middle of the list, we would have to traverse the list until we encountered it.</li>
</ul></li>
<li>The two main types of linked lists that we talked about are Singly Linked Lists and Doubly Linked Lists.
<ul>
<li>Singly Linked Lists are composed of nodes that only have a reference to the next node in the list. We can only traverse the list in one direction.</li>
<li>Doubly Linked Lists are composed of nodes that have a reference to both the next node and the previous node in the list. This allows us to traverse both forwards and backwards.</li>
</ul></li>
<li>Methods of a linked list that we should know are:
<ul>
<li>addToTail: Adds a new node to the end of the list.</li>
<li>addToHead: Adds a new node to the front of the list.</li>
<li>insertAt: Adds a new node at the specified position (we need to traverse to that point, then update pointers)</li>
<li>removeTail: Removes the last node of the list.</li>
<li>removeHead: Removes the first node of the list.</li>
<li>removeFrom: Removes the node at the specified position.</li>
<li>contains: Traverses the list and returns a boolean to indicate if the value was found at any node.</li>
<li>get: Returns a reference to the node at the specified position.</li>
<li>set: Updates the value of the node at the specified position.</li>
<li>size: Returns the current length of the list.</li>
</ul></li>
<li>Time complexities for these methods:
<ul>
<li>Accessing a node: O(n), because we may have to traverse the entire list.</li>
<li>Searching a list: O(n), because we may have to traverse the entire list.</li>
<li>Inserting a value: O(1), under the assumption that we have a reference to the node that we want to insert it after/before. If we donâ€™t have this reference we would first have to access it (O(n) from above), but the actual creation is O(1)</li>
<li>Deleting a node: O(1), for the same reasons as insertion. If we first need to find the previous and next nodes, we would need to access them (O(n) from above), but the actual deletion is O(1)</li>
</ul></li>
<li>Be able to implement a Singly Linked List and a Doubly Linked List. This would require you to use a Node class with a value instance variable and an instance variable that points to the next (and possibly previous) Node instance(s). You should then be able to interact with these Nodes to perform all of the actions of a Linked List, as we defined above.</li>
</ul>
<ol start="2" type="1">
<li>Explain and implement a Stack.</li>
</ol>
<ul>
<li>A Last In First Out (LIFO) Abstract Data Type (ADT).
<ul>
<li>LIFO: The last element put into the stack is the first thing removed from it. Think of it as a can of Pringles or a pile of dishes.</li>
<li>ADT: The actual implementation of the stack can vary as long as the main principles and methods associated with them are abided by. We could use Nodes like we did with Linked Lists, we could use an Array as an underlying instance variable as long as the methods we implement only interact with it in the way a stack should be interacted with, etc.</li>
</ul></li>
<li>Methods of a Stack we should know are:
<ul>
<li>push: Adds an element to the top of the stack.</li>
<li>pop: Removes an element from the top of the stack.</li>
<li>peek: Returns the value of the top element of the stack.</li>
<li>size: Returns the number of elements in the stack.</li>
</ul></li>
<li>Time Complexities:
<ul>
<li>Adding an element: O(1), since we are always adding it to the top and the addition doesnâ€™t affect any other elements.</li>
<li>Removing an element: O(1), weâ€™re always taking the top element of the stack.</li>
<li>Finding or Accessing a particular element: O(n), since we can only interact with our stack by removing elements from the top, we may have to remove every element to find what weâ€™re looking for.</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li>Explain and implement a Queue.</li>
</ol>
<ul>
<li>A First In First Out (LIFO) Abstract Data Type (ADT).
<ul>
<li>LIFO: The first element put into the queue is the first thing removed from it. Think of it as if you are waiting in line at a store, first come, first serve.</li>
<li>ADT: The actual implementation of the queue can vary as long as the main principles and methods associated with them are abided by. We could use Nodes like we did with Linked Lists, we could use an Array as an underlying instance variable as long as the methods we implement only interact with it in the way a queue should be interacted with, etc.</li>
</ul></li>
<li>Methods of a Queue we should know are:
<ul>
<li>enqueue: Adds an element to the back of the queue.</li>
<li>dequeue: Removes an element from the front of the queue.</li>
<li>peek: Returns the value of the front element of the queue.</li>
<li>size: Returns the number of elements in the queue.</li>
</ul></li>
<li>Time Complexities:
<ul>
<li>Adding an element: O(1), since we are always adding it to the back. If we are using Nodes instead of a simple array, keeping a reference to the last node allows us to immediately update these pointers without having to do any traversal.</li>
<li>Removing an element: O(1), weâ€™re always taking the front element of the queue.</li>
<li>Finding or Accessing a particular element: O(n), since we can only interact with our queue by removing elements from the front, we may have to remove every element to find what weâ€™re looking for.</li>
</ul></li>
</ul>
<h2 id="heaps-w7d5">Heaps (W7D5)</h2>
<p>Not on the assessment donâ€™t worry</p>
