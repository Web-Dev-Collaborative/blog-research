<h1 id="big-o-memoization-and-tabulation-w7d3---learning-objectives">Big-O, Memoization, and Tabulation (W7D3) - Learning Objectives</h1>
<h2 id="big-o">Big-O</h2>
<ol type="1">
<li><p>Order the common complexity classes according to their growth rate</p>
<ul>
<li>The following are in order from smallest growth (most efficient) to largest:
<ul>
<li>constant O(1)</li>
<li>logarithmic O(log n)</li>
<li>linear O(n)</li>
<li>loglinear, linearithmic, quasilinear O(n log n)</li>
<li>polynomial O(n^c) -&gt; O(n^2), O(n^3)</li>
<li>exponential O(c^n) -&gt; O(2^n), O(3^n)</li>
<li>factorial O(n!)</li>
</ul></li>
</ul></li>
<li><p>Identify the complexity classes of common sort methods</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Sort Name</th>
<th style="text-align: left;">Time Complexity</th>
<th style="text-align: left;">Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">bubble</td>
<td style="text-align: left;">O(n^2)</td>
<td style="text-align: left;">O(1)</td>
</tr>
<tr class="even">
<td style="text-align: left;">selection</td>
<td style="text-align: left;">O(n^2)</td>
<td style="text-align: left;">O(1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">insertion</td>
<td style="text-align: left;">O(n^2)</td>
<td style="text-align: left;">O(1)</td>
</tr>
<tr class="even">
<td style="text-align: left;">merge</td>
<td style="text-align: left;">O(n log n)</td>
<td style="text-align: left;">O(n)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">quick</td>
<td style="text-align: left;">O(n log n)/O(n^2)</td>
<td style="text-align: left;">O(n)/O(log n)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>quick sort’s complexities are a little more complicated</strong>
<ul>
<li>We are generally only concerned with the worst-scenario when we talk Big-O.</li>
<li>With quick sort, the worst case is exceedingly rare (only occurs when our pivot for each round happens to be the next element, resulting in us having to choose n pivot points)</li>
<li>Because it is so rare that this occurs, most people will use consider quick sort to be closer to O(n log n) time complexity.</li>
<li>We also have two space complexities listed. The version that we used in class creates a new array, resulting in O(n) space. With some tweaking, we can sort in place, modifying the original array and cutting our space complexity to O(log n), which is just a result of the stack frames that we have to create. It’s good to know this method exists, but you will not need to create or identify this version.</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li>Identify complexity classes of code</li>
</ol>
<ul>
<li><p>Important takeaway here is being able to connect code patterns with time complexities</p>
<ul>
<li><p>Doing an exact number of calculations (independent of input) -&gt; constant O(1) time</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">function</span> <span class="at">constant_1</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="cf">return</span> n <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Looping an exact number of times (independent of input) -&gt; constant O(1) time</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">function</span> <span class="at">constant_2</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(i)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Recursive calls that divide the input -&gt; logarithmic O(log n) time</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span> <span class="at">logarithmic</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="cf">if</span> (n <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="at">logarithmic</span>(n / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Loops that depend on the size of the input -&gt; linear O(n) time</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">function</span> <span class="at">linear_1</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(i)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Recursive calls that depend on the size of the input (decrementing instead of dividing) -&gt; linear O(n) time</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">function</span> <span class="at">linear_2</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="at">linear_2</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Looping through input on each stack frame, while recursively dividing our data (commonly seen in sorts like merge and quick sort) -&gt; loglinear O(n log n) time</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">function</span> <span class="at">loglinear</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="cf">if</span> (n <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span> <span class="co">// n calculations in each stack frame</span></a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="at">loglinear</span>(n / <span class="dv">2</span>)<span class="op">;</span> <span class="co">// log n number of stack frames</span></a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="at">loglinear</span>(n / <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Nesting loops that depend on the size of the input -&gt; polynomial O(n^c) time</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="co">// O(n^2)</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">function</span> <span class="at">quadratic</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-5" title="5">      <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`</span><span class="sc">${</span>i<span class="sc">}</span><span class="vs">, </span><span class="sc">${</span>j<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb7-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="co">// O(n^3)</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="kw">function</span> <span class="at">cubic</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-12" title="12">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-13" title="13">    <span class="cf">for</span> (<span class="kw">let</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-14" title="14">      <span class="cf">for</span> (<span class="kw">let</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;=</span> n<span class="op">;</span> k<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-15" title="15">        <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`</span><span class="sc">${</span>i<span class="sc">}</span><span class="vs">, </span><span class="sc">${</span>j<span class="sc">}</span><span class="vs">, </span><span class="sc">${</span>k<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-16" title="16">      <span class="op">}</span></a>
<a class="sourceLine" id="cb7-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb7-18" title="18">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-19" title="19"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Branching out on each recursive call, with the number of calls dependent on the size of the input -&gt; exponential O(c^n) time</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// O(2^n)</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">function</span> <span class="at">exponential_2n</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="at">exponential_2n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="at">exponential_2n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="co">// O(3^n)</span></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">function</span> <span class="at">exponential_3n</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-11" title="11">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-12" title="12">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-13" title="13">  <span class="at">exponential_3n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-14" title="14">  <span class="at">exponential_3n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-15" title="15">  <span class="at">exponential_3n</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="op">}</span></a></code></pre></div>
<ul>
<li>When both the number of recursive calls and the number of branches made in the calls are dependent on the size of the input -&gt; factorial O(n!) time</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">function</span> <span class="at">factorial</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(n)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span> <span class="co">// Here we&#39;re making n branches on this frame</span></a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="at">factorial</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span> <span class="co">// Since we are decrementing, we&#39;re making n stack frames</span></a>
<a class="sourceLine" id="cb9-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="op">}</span></a></code></pre></div></li>
</ul></li>
</ul>
<h3 id="memoization-and-tabulation">Memoization and Tabulation</h3>
<ol type="1">
<li><p>Apply memoization to recursive problems to make them less than polynomial time.</p>
<ul>
<li>Main steps for memoizing a problem:
<ol type="1">
<li>Write out the brute force recursion</li>
<li>Add the memo object as an additional argument</li>
</ol>
<ul>
<li>Keys on this object represent input, values are the corresponding output</li>
</ul>
<ol start="3" type="1">
<li>Add a base condition that returns the stored value if the argument is already in the memo</li>
<li>Before returning a calculation, store the result in the memo for future use</li>
</ol></li>
<li>Example of a standard and memoized fibonacci:</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="co">// Standard Implementation</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">// Time Complexity: O(2^n)</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">//   - For each call to fib, we have to make two branches, with n levels to this tree</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">function</span> <span class="at">fib</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span> <span class="op">||</span> n <span class="op">===</span> <span class="dv">2</span>) <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="cf">return</span> <span class="at">fib</span>(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> <span class="at">fib</span>(n <span class="op">-</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="co">// Using memoization</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="co">// Time Complexity: O(n)</span></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="co">//   - We only ever have to calculate fib(x) one time, every other time that we use it in a larger problem, the result is immediately accessible in our memo</span></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="co">//   - The memo removes the repeated trees of calculations from our original code</span></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="kw">function</span> <span class="at">fib</span>(n<span class="op">,</span> memo <span class="op">=</span> <span class="op">{}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb10-14" title="14">  <span class="cf">if</span> (n <span class="kw">in</span> memo) <span class="cf">return</span> memo[n]<span class="op">;</span> <span class="co">// If we already calculated this value, return it</span></a>
<a class="sourceLine" id="cb10-15" title="15">  <span class="cf">if</span> (n <span class="op">===</span> <span class="dv">1</span> <span class="op">||</span> n <span class="op">===</span> <span class="dv">2</span>) <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb10-16" title="16"></a>
<a class="sourceLine" id="cb10-17" title="17">  <span class="co">// Store the result in the memo first before returning</span></a>
<a class="sourceLine" id="cb10-18" title="18">  <span class="co">// Make sure to pass the memo in to your calls to fib!</span></a>
<a class="sourceLine" id="cb10-19" title="19">  memo[n] <span class="op">=</span> <span class="at">fib</span>(n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo) <span class="op">+</span> <span class="at">fib</span>(n <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> memo)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-20" title="20">  <span class="cf">return</span> memo[n]<span class="op">;</span></a>
<a class="sourceLine" id="cb10-21" title="21"><span class="op">}</span></a></code></pre></div></li>
<li><p>Apply tabulation to iterative problems to make them less than polynomial time.</p>
<ul>
<li>Main considerations for using tabulation:
<ul>
<li>Figure out how big is your table
<ul>
<li>Typically going to be base on input size (number in fibonacci, length of string in wordBreak)</li>
</ul></li>
<li>What does my table represent?
<ul>
<li>You are generally building up your answer.</li>
<li>In fibonacci, we used the table to store the fib number at the corresponding index.</li>
<li>In stepper, we stored the boolean of whether it was possible to get to that location.</li>
</ul></li>
<li>What initial values do I need to seed?
<ul>
<li>Consider what your end result should be (boolean, number, etc.).</li>
<li>Your seed data is generally going to be the immediate answer that we know from our base condition.</li>
<li>In fibonacci, we knew the first two numbers of the series.</li>
<li>In stepper, we knew that it was possible to get to our starting location, so we seeded it as true, defaulting the rest to false so that we could later change its value if we could make that step.</li>
</ul></li>
<li>How do I iterate and fill out my table?
<ul>
<li>We typically need to iterate over or up to our input in some way in order to update and build up our table until we get our final result.</li>
<li>In fibonacci, we iterated up to our input number in order to calculate the fib number at each step.</li>
<li>In stepper, we iterated over each possible stepping location. If we could have made it to that point from our previous steps (ie that index was true in our table), we continued updating our table by marking the possible landing spots as true.</li>
</ul></li>
</ul></li>
<li><p>Example of a tabulated fibonacci:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="co">// Using tabulation</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">// Time Complexity: O(n)</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co">//   - We are iterating through an array directly related to the size of the input and performing a constant number of calculations at each step (adding our two previous values together and storing the result in the array).</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="kw">function</span> <span class="at">fib</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-5" title="5">  <span class="co">// We create a table to track our values as we build them up</span></a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="co">// We&#39;re making it n+1 here so that table[n] lines up with the nth fib number</span></a>
<a class="sourceLine" id="cb11-7" title="7">  <span class="co">// This is because arrays are zero-indexed.</span></a>
<a class="sourceLine" id="cb11-8" title="8">  <span class="co">// We could have used an array of length n, but we would have to remember that </span></a>
<a class="sourceLine" id="cb11-9" title="9">  <span class="co">// the nth fib number would then be stored at table[n-1]. Completely doable,</span></a>
<a class="sourceLine" id="cb11-10" title="10">  <span class="co">// but I think making them line up is more intuitive.</span></a>
<a class="sourceLine" id="cb11-11" title="11">  <span class="kw">let</span> table <span class="op">=</span> <span class="kw">new</span> <span class="at">Array</span>(n <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-12" title="12">  <span class="co">// Seed our table with our starting values.</span></a>
<a class="sourceLine" id="cb11-13" title="13">  <span class="co">// Again, if we had a table of length n, we could have seeded table[0] = 1</span></a>
<a class="sourceLine" id="cb11-14" title="14">  <span class="co">// and table[1] = 1 and had the same final result with our indices shifted.</span></a>
<a class="sourceLine" id="cb11-15" title="15">  table[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-16" title="16">  table[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-17" title="17"></a>
<a class="sourceLine" id="cb11-18" title="18">  <span class="co">// Iterate through our input and fill out our table as we go.</span></a>
<a class="sourceLine" id="cb11-19" title="19">  <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">table</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-20" title="20">    table[i] <span class="op">=</span> table[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> table[i <span class="op">-</span> <span class="dv">2</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb11-21" title="21">  <span class="op">}</span></a>
<a class="sourceLine" id="cb11-22" title="22"></a>
<a class="sourceLine" id="cb11-23" title="23">  <span class="co">// At the end, the final entry in our table is the result we are looking for.</span></a>
<a class="sourceLine" id="cb11-24" title="24">  <span class="co">// The table holds all of the sub-answers that we used to get to this result.</span></a>
<a class="sourceLine" id="cb11-25" title="25">  <span class="cf">return</span> table[n]<span class="op">;</span></a>
<a class="sourceLine" id="cb11-26" title="26"><span class="op">}</span></a></code></pre></div></li>
</ul></li>
</ol>
