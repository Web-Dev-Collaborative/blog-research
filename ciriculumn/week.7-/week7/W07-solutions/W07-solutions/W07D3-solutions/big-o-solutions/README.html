<h1 id="intro-to-big-o-project">Intro to Big O Project</h1>
<p>This project contains four phases and will prompt you to determine the time and space complexities of the functions that you write.</p>
<p>Clone the project from https://github.com/appacademy-starters/big-o-intro-project.</p>
<h2 id="learning-goals">Learning Goals</h2>
<ul>
<li>Be able to determine and explain the time and space complexity of a function</li>
<li>Be able to recognize when and how time or space complexity can be improved</li>
<li>Be able to compare the time complexity of one function to another</li>
<li>Be able to reason about a difficult problem and think of ways to solve it.</li>
</ul>
<h2 id="phase-1-big-o-ctopus-and-biggest-fish">Phase 1: Big O-ctopus and Biggest Fish</h2>
<p>Fill out the functions in the <code>01-big-octopus.js</code> file using the directions below.</p>
<p>A Very Hungry Octopus wants to eat the longest fish in an array of fish.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">const</span> fishies <span class="op">=</span> [<span class="st">&#39;fish&#39;</span><span class="op">,</span> <span class="st">&#39;fiiish&#39;</span><span class="op">,</span> <span class="st">&#39;fiiiiish&#39;</span><span class="op">,</span> <span class="st">&#39;fiiiish&#39;</span><span class="op">,</span> <span class="st">&#39;fffish&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="st">&#39;ffiiiiisshh&#39;</span><span class="op">,</span> <span class="st">&#39;fsh&#39;</span><span class="op">,</span> <span class="st">&#39;fiiiissshhhhhh&#39;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">// =&gt; &quot;fiiiissshhhhhh&quot;;</span></a></code></pre></div>
<h3 id="sluggish-octopus">Sluggish Octopus</h3>
<p>Find the longest fish in O(n^2) time. Do this by comparing all fish lengths to all other fish lengths</p>
<h3 id="dominant-octopus">Dominant Octopus</h3>
<p>Find the longest fish in O(n log n) time. Hint: Use the built in <code>Array.sort()</code> method which runs in O(n log n). Remember that Big O is classified by the dominant term.</p>
<h3 id="clever-octopus">Clever Octopus</h3>
<p>Find the longest fish in O(n) time. The octopus can hold on to the longest fish that you have found so far while stepping through the array only once.</p>
<h2 id="dancing-octopus">Dancing Octopus</h2>
<p>Full of fish, the Octopus attempts <a href="https://en.wikipedia.org/wiki/Dance_Dance_Revolution">Dance Dance Revolution</a>. The game has tiles in the following directions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> tilesArray <span class="op">=</span> [<span class="st">&quot;up&quot;</span><span class="op">,</span> <span class="st">&quot;right-up&quot;</span><span class="op">,</span> <span class="st">&quot;right&quot;</span><span class="op">,</span> <span class="st">&quot;right-down&quot;</span><span class="op">,</span> <span class="st">&quot;down&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="st">&quot;left-down&quot;</span><span class="op">,</span> <span class="st">&quot;left&quot;</span><span class="op">,</span>  <span class="st">&quot;left-up&quot;</span> ]<span class="op">;</span></a></code></pre></div>
<p>To play the game, the octopus must step on a tile with her corresponding tentacle. We can assume that the octopus’s eight tentacles are numbered and correspond to the tile direction indices.</p>
<h3 id="slow-dance">Slow Dance</h3>
<p>Given a tile direction, iterate through a tiles array to return the tentacle number (tile index) the octopus must move. This should take O(n) time.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="at">slowDance</span>(<span class="st">&quot;up&quot;</span><span class="op">,</span> tilesArray)<span class="op">;</span> <span class="co">// 0</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="at">slowDance</span>(<span class="st">&quot;right-down&quot;</span><span class="op">,</span> tilesArray)<span class="op">;</span> <span class="co">// 3</span></a></code></pre></div>
<h3 id="constant-dance">Constant Dance!</h3>
<p>Now that the octopus is warmed up, let’s help her dance faster. Use a different data structure and write a new function so that you can access the tentacle number in O(1) time.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="at">fastDance</span>(<span class="st">&quot;up&quot;</span><span class="op">,</span> newTilesDataStructure)<span class="op">;</span> <span class="co">// 0</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="at">fastDance</span>(<span class="st">&quot;right-down&quot;</span><span class="op">,</span> newTilesDataStructure)<span class="op">;</span> <span class="co">// 3</span></a></code></pre></div>
<h2 id="phase-2-anagrams">Phase 2: Anagrams</h2>
<p>Fill out the functions in the <code>02-anagrams.js</code> file using the directions below.</p>
<p>Our goal today is to write a method that determines if two given words are anagrams. This means that the letters in one word can be rearranged to form the other word. For example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="at">isAnagram</span>(<span class="st">&quot;gizmo&quot;</span><span class="op">,</span> <span class="st">&quot;sally&quot;</span>)<span class="op">;</span>    <span class="co">// =&gt; false</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="at">isAnagram</span>(<span class="st">&quot;elvis&quot;</span><span class="op">,</span> <span class="st">&quot;lives&quot;</span>)<span class="op">;</span>    <span class="co">// =&gt; true</span></a></code></pre></div>
<p>Assume that there is no whitespace or punctuation in the given strings.</p>
<h3 id="first-anagram">First Anagram</h3>
<p>Write a method <code>firstAnagram</code> that iterates over the first string. For each letter in the first string, find the index of that letter in the second string (hint: use <code>Array.indexOf()</code>) and delete at that index. The two strings are anagrams if an index is found for every letter and the second string is empty at the end of the iteration.</p>
<h3 id="second-anagram">Second Anagram</h3>
<p>Write a method <code>secondAnagram</code> that solves the problem by sorting both strings alphabetically. The strings are then anagrams if and only if the sorted versions are the identical.</p>
<p>What is the time complexity of this solution? Is it better or worse than <code>firstAnagram</code>?</p>
<h3 id="third-anagram">Third Anagram</h3>
<p>Write one more method <code>thirdAnagram</code>. This time, use two Objects to store the number of times each letter appears in both words. Compare the resulting Objects.</p>
<p>What is the time complexity?</p>
<p><strong>Bonus:</strong> Do it with only one Object.</p>
<p>Discuss the time complexity of your solutions together, then <strong>call over your TA</strong> to get a code review and go over the time and space complexity of each anagram function.</p>
<h2 id="phase-3-two-sum">Phase 3: Two Sum</h2>
<p>Fill out the functions in the <code>03-two-sum.js</code> file using the directions below.</p>
<p>Given an array of unique integers and a target sum, determine whether any two integers in the array sum to that amount.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">function</span> <span class="at">twoSum</span>(arr<span class="op">,</span> targetSum)<span class="op">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="co">// your code here...</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">const</span> arr <span class="op">=</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">7</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="at">twoSum</span>(arr<span class="op">,</span> <span class="dv">6</span>)<span class="op">;</span> <span class="co">// =&gt; should be true</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="at">twoSum</span>(arr<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span> <span class="co">// =&gt; should be false</span></a></code></pre></div>
<p><strong>Before you start coding anything, talk it over with your partner. Sketch out on paper how you’d approach this problem. What would be the running time of your proposed solution? Take as long as you need, but don’t write any code yet.</strong></p>
<h3 id="brute-force">Brute force</h3>
<p>If we weren’t worried about time complexity, what would be the most straightforward way to solve this problem? To start with, we could check every possible pair. If we sum each element with every other, we’re sure to either find the pair that sums to the target, or determine that no such pair exists.</p>
<p>This is the <strong>brute force</strong> solution. It’s essentially hitting the problem with a sledge hammer. There are faster and more elegant ways to solve the problem, but we know for sure that this will get the job done.</p>
<p>Let’s start by implementing the brute force solution. Write a method called <code>badTwoSum</code>, which checks every possible pair.</p>
<p>Make sure that you don’t pair an element with itself. However, you don’t need to bother checking for summing the same pair twice; that won’t affect your result.</p>
<p>(Note: you can cut the running-time significantly by returning early, and by not checking pairs more than once. However, these micro-optimizations will not improve the time complexity of the solution. Do you see why?)</p>
<p>Once you’re done, write a comment with your solution’s time complexity.</p>
<h3 id="sorting">Sorting</h3>
<p>As a person of elevated algorithmic sensibilities, the brute-force approach is beneath you. Leave that nonsense to the riffraff. Instead, you’ll apply a refined and time-honored technique: <strong>sorting</strong>.</p>
<p>Sort your data, then try to solve the problem.</p>
<ol type="1">
<li>What does sorting do to the lower bound of your time complexity?</li>
<li>How might sorting that make the problem easier?</li>
</ol>
<p>Write a second solution, called <code>okayTwoSum</code>, which uses sorting. Make sure it works correctly.</p>
<p><em>Hint: (There are a couple ways to solve this problem once it’s sorted. One way involves using a very cheap algorithm that can only be used on sorted data sets. What are some such algorithms you know? Binary Search would work.)</em></p>
<h3 id="objects">Objects</h3>
<p>Finally, it’s time to bust out the big guns: objects. Remember, an object has <em>O(1)</em> <code>add</code> and <em>O(1)</em> <code>get</code>, so you can build an object by iterating over each of the <code>n</code> elements in your array in <em>O(n)</em> time. That object prevents you from having to repeatedly find values in the array; now you can just look them up instantly.</p>
<p>See if you can solve the <code>twoSum</code> problem in linear time now, using your object.</p>
<p>Once you’re finished, make sure you understand the time complexity of your solutions and then <strong>call over your TA</strong> and show them what you’ve got. Defend to them why each of your solutions has the time complexity you claim it does.</p>
<h2 id="phase-4-execution-time-difference">Phase 4: Execution Time Difference</h2>
<h3 id="minimum-number">Minimum Number</h3>
<p>Given a list of integers find the smallest number in the list.</p>
<p>Example:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1">    <span class="kw">const</span> list <span class="op">=</span> [ <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">-5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">90</span> ]</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="at">myMin</span>(list)  <span class="co">// =&gt;  -5</span></a></code></pre></div>
<h4 id="mymin1a"><code>myMin1a</code></h4>
<p>First, write a function that compares each element to every other element of the list. Return the element if all other elements in the array are larger.<br />
What is the time complexity for this function?</p>
<h4 id="mymin1b"><code>myMin1b</code></h4>
<p>What is the space complexity for <code>myMin1a</code>? If it is greater than constant space, then implement <code>myMin1b</code> with in the same way that you did <code>myMin1a</code> except with constant space. If <code>myMin1a</code> is already implemented with constant space complexity, skip this function.</p>
<h4 id="mymin2"><code>myMin2</code></h4>
<p>Now rewrite the function to iterate through the list just once while keeping track of the minimum. What are the time and space complexities?</p>
<h3 id="largest-contiguous-sub-sum">Largest Contiguous Sub-sum</h3>
<p>You have an array of integers and you want to find the largest contiguous (together in sequence) sub-sum. Find the sums of all contiguous sub-arrays and return the max.</p>
<p>Example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1">    array <span class="op">=</span> [<span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">-7</span>]</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="at">largestContiguousSubsum</span>(array) <span class="co">// =&gt; 8</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="co">// possible sub-sums</span></a>
<a class="sourceLine" id="cb8-5" title="5">    [<span class="dv">5</span>]           <span class="co">// =&gt; 5</span></a>
<a class="sourceLine" id="cb8-6" title="6">    [<span class="dv">5</span><span class="op">,</span> <span class="dv">3</span>]        <span class="co">// =&gt; 8 --&gt; we want this one</span></a>
<a class="sourceLine" id="cb8-7" title="7">    [<span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">-7</span>]    <span class="co">// =&gt; 1</span></a>
<a class="sourceLine" id="cb8-8" title="8">    [<span class="dv">3</span>]           <span class="co">// =&gt; 3</span></a>
<a class="sourceLine" id="cb8-9" title="9">    [<span class="dv">3</span><span class="op">,</span> <span class="dv">-7</span>]       <span class="co">// =&gt; -4</span></a>
<a class="sourceLine" id="cb8-10" title="10">    [<span class="op">-</span><span class="dv">7</span>]          <span class="co">// =&gt; -7</span></a></code></pre></div>
<p>Example 2:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1">    array <span class="op">=</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">-6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">-6</span><span class="op">,</span> <span class="dv">7</span>]</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="at">largestContiguousSubsum</span>(array) <span class="co">// =&gt; 8 (from [7, -6, 7])</span></a></code></pre></div>
<p>Example 3:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1">    array <span class="op">=</span> [<span class="op">-</span><span class="dv">5</span><span class="op">,</span> <span class="dv">-1</span><span class="op">,</span> <span class="dv">-3</span>]</a>
<a class="sourceLine" id="cb10-2" title="2">    <span class="at">largestContiguousSubsum</span>(array) <span class="co">// =&gt; -1 (from [-1])</span></a></code></pre></div>
<h4 id="first-attempt">First Attempt</h4>
<p>Write a function that iterates through the array and finds all sub-arrays using nested loops. First make an array to hold all sub-arrays. Then find the sums of each sub-array and return the max.</p>
<p>Discuss the time and space complexities of this solution.</p>
<h4 id="second-attempt">Second Attempt</h4>
<p>Let’s make a better version. Write a new function using O(n) time with O(1) memory. Keep a running tally of the largest sum. To accomplish this efficient space complexity, consider using two variables. One variable should track the largest sum so far and another to track the current sum. We’ll leave the rest to you.</p>
<p>Get your story straight, then <strong>call over your TA</strong> and explain your solutions’ time and space complexities for each function.</p>
